<!-- ---
hide:
  - navigation # Hide navigation
  - toc        # Hide table of contents
--- -->

# Data Structures & Algorithms
`Author: Vinay Kumar (@imflash217) | Date: 03/October/2021`

<!-- ######################################################################################################### -->

## 1.1: Unpacking a sequence into separate variables

???+ danger "Problem"
    You have a `N-element` tuple or sequence that you would like to unpack into a collection of `N` variables.

???+ done "Solution"
    1. Any **sequence** or **iterable** can be unpacked into variables using a simple assignment operation.
    2. The only requirement is that the **the numbe rof variables and structure of the sequence must match**.

    ```python
    ##----------------------------------------------------------
    p = (4,5)   ## create a tuple
    x, y = p    ## unpack the tuple into variables 'x' & 'y'. 
                ## x=4; y=5
    ##----------------------------------------------------------
    data = ["ACME", 50, 91.1, (2021,10,07)]
    name, shares, price, date = data    ## unpack the list
                                        ## name="ACME"; shares=50
                                        ## price=91.1; date=(2021,10,07)

    ## another way to unpack the nested iterable or container
    ## name="ACME"; shares=50; price=91.1; 
    ## year = 2021; month=10; day=07
    name, shares, price, (year, month, day) = data
    ```

    If there is a mismatch in the number of elements; you will get an ERROR.
    ```python
    p = (4, 5)
    x, y, z = p
    ```
    ```shell
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        ValueError: need more than 2 values to unpack
    ```

???+ quote "Discussion"
    ```
    for i = 1, 2, 3, ..., n{
        insert A[i] into sorted array A[0:i-1]
        by "pairwise swaps" down to the correct position
    }
    ```
    ![insertion sort](../../assets/blogs/algorithms/blog_01312021_insertion_sort/1.jpg)

    This above version has **$\theta(n)$** steps and each step has **$\theta(n)$** comparisons. SO this version of the algorithm is **$\theta(n^2)$** runtime complexity.

