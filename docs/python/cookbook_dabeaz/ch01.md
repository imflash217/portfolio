<!-- ---
hide:
  - navigation # Hide navigation
  - toc        # Hide table of contents
--- -->

# Data Structures & Algorithms
`Author: Vinay Kumar (@imflash217) | Update: 07/October/2021`

<!-- ######################################################################################################### -->

## 1.1: Unpacking a sequence into separate variables

???+ danger "Problem"
    You have a `N-element` tuple or sequence that you would like to unpack into a collection of `N` variables.

???+ done "Solution"
    1. Any **sequence** or **iterable** can be unpacked into variables using a simple assignment operation.
    2. The only requirement is that the **the number of variables and structure of the sequence must match**.

    ```python
    ##----------------------------------------------------------
    p = (4,5)   ## create a tuple
    x, y = p    ## unpack the tuple into variables 'x' & 'y'. 
                ## x=4; y=5
    ##----------------------------------------------------------
    data = ["ACME", 50, 91.1, (2021,10,07)]
    name, shares, price, date = data    ## unpack the list
                                        ## name="ACME"; shares=50
                                        ## price=91.1; date=(2021,10,07)

    ## another way to unpack the nested iterable or container
    ## name="ACME"; shares=50; price=91.1; 
    ## year = 2021; month=10; day=07
    name, shares, price, (year, month, day) = data
    ```

    If there is a mismatch in the number of elements; you will get an ERROR.
    ```python
    p = (4, 5)
    x, y, z = p
    ```
    ```console
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        ValueError: need more than 2 values to unpack
    ```

???+ quote "Discussion"
    Unpacking actually works with any object that happens to be **iterable** (tuples, lists, dicts, str, files, iteratirs, generators...)


<!-- ######################################################################################################### -->

## `1.2:` Unpacking elements from iterables of arbitrary length

???+ danger "Problem"
    You need to unpack `N` elements from an **iterable**; but the iterable may be longer than `N` elements (causing a `too many values to unpack` exception)

???+ done "Solution"
    



<!-- ######################################################################################################### -->

## `1.3` Keeping last `N` items

???+ danger "Problem"
    You want to keep a limited history of last few items seen during iteration.

???+ done "Solution"
    1. Keeping a limited history is a perfect use for `collections.deque`

    ```python
    """
    Performs a simple text match on a sequence of lines
    and yields the matching line & previous N lines of context when found
    """

    from collections import deque

    def search(lines, pattern, history=5):
        previous_lines = deque(maxlen=history)
        for line in lines:
            if pattern in line:
                yield line, previous_lines
            previous_lines.append(line)
    
    ## Example use ona file
    if __name__ == "__main__":
        with open("somefile.txt", "r") as f:
            for line, prev_lines in search(f, "my_pattern"):
                for x in lines:
                    print(x, end="")
                print(line, end="")
                print("--"*10)
    ```






