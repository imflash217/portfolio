<!-- ---
hide:
  - navigation # Hide navigation
  - toc        # Hide table of contents
--- -->

# Data Structures & Algorithms

<!-- ######################################################################################################### -->

## 1.1: Unpacking a sequence into separate variables

???+ danger "Problem"
    You have a `N-element` tuple or sequence that you would like to unpack into a collection of `N` variables.

???+ done "Solution"
    1. Any **sequence** or **iterable** can be unpacked into variables using a simple assignment operation.
    2. The only requirement is that the **the number of variables and structure of the sequence must match**.

    ```python
    ##----------------------------------------------------------
    p = (4,5)   ## create a tuple
    x, y = p    ## unpack the tuple into variables 'x' & 'y'. 
                ## x=4; y=5
    ##----------------------------------------------------------
    data = ["ACME", 50, 91.1, (2021,10,07)]
    name, shares, price, date = data    ## unpack the list
                                        ## name="ACME"; shares=50
                                        ## price=91.1; date=(2021,10,07)

    ## another way to unpack the nested iterable or container
    ## name="ACME"; shares=50; price=91.1; 
    ## year = 2021; month=10; day=07
    name, shares, price, (year, month, day) = data
    ```

    If there is a mismatch in the number of elements; you will get an ERROR.
    ```python
    p = (4, 5)
    x, y, z = p
    ```
    ```zsh
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        ValueError: need more than 2 values to unpack
    ```

???+ quote "Discussion"
    Unpacking actually works with any object that happens to be **iterable** (tuples, lists, dicts, str, files, iteratirs, generators...)


<!-- ######################################################################################################### -->

## 1.2: Unpacking elements from iterables of arbitrary length

???+ danger "Problem"
    You need to unpack `N` elements from an **iterable**; but the iterable may be longer than `N` elements (causing a `too many values to unpack` exception)

???+ done "Solution"
    



<!-- ######################################################################################################### -->

## 1.3 Keeping last N items

???+ danger "Problem"
    You want to keep a limited history of last few items seen during iteration.

???+ done "Solution"
    1. Keeping a limited history is a perfect use for `collections.deque`

    ```python
    """
    Performs a simple text match on a sequence of lines
    and yields the matching line & previous N lines of context when found
    """

    from collections import deque

    def search(lines, pattern, history=5):
        previous_lines = deque(maxlen=history)
        for line in lines:
            if pattern in line:
                yield line, previous_lines
            previous_lines.append(line)

    ##-----------------------------------------------------------##
    ## Example use ona file
    if __name__ == "__main__":
        with open("somefile.txt", "r") as f:
            for line, prev_lines in search(f, "my_pattern"):
                for x in lines:
                    print(x, end="")
                print(line, end="")
                print("--"*10)
    ```


<!-- ######################################################################################################### -->

## 1.5: Priority Queue

???+ danger "Problem"
    You want to implement a `queue` that sorts items by a given priority 
    & always **returns the item with highest priority** on each `pop` operation.

???+ done "Solution"
    The following class uses `heapq` module to implement a simple **priority queue**
    
    ```python
    import heapq
    
    class PriorityQueue:
        def __init__(self):
            self._queue = []
            self._idx = 0

        def __repr__(self):
            return self._queue

        def push(self, item, priority):
            
            ## because heappop returns the 1st item in the queue 
            ## (which has the smallest priority);
            ## So, we need to invert the priority as (-priority)
            ## Thus, we get the item with highest priority on pop

            heapq.heappush(self._queue, (-priority, self._idx, item))
            self._idx += 1

        def pop(self):
            """
            Returns item with HIGHEST priority in the priority queue
            """
            result = heapq.heappop(self._queue)     ## a tuple of type (-priority, idx, item)
            return result[-1]                       ## "item" from above line
    ```

    Here is an example of how we might use the above `PriorityQueue` class

    ```python
    class Item:
        def __init__(self, name):
            self.name = name

        def __repr__(self):
            return f"Item({self.name})"

    ##-----------------------------------------------------------##
    
    q = PriorityQueue()                 ## Create a priority-queue object
    q.push(Item("foo"), priority=1)     ## push an Item("foo") with priority=1
    q.push(Item("bar"), priority=5)     ## push an Item("bar") with priority=5
    q.push(Item("spam"), priority=4)    ## push an Item("spam") with priority=4
    q.push(Item("grok"), priority=1)    ## push an Item("grok") with priority=1
        
    q.pop()                             ## Item("bar")
    q.pop()                             ## Item("spam")
    q.pop()                             ## Item("foo")
    q.pop()                             ## Item("grok")
    
    ```

    In the above example note that the items with same priority (`Item("foo")` and `Item("grok")`)
    are returned in the same order as they were inserted into the queue.

???+ quote "Discussion"
    The core of this recipe concerns with the use of `heapq` module.
    The methods `heapq.heappush()` and `heapq.heappop()` insert and remove items
    from `self._queue` in such a way that the first tem in the list has the **smallest priority**.

    The `heappop()` method always returns the **smallest** item; so that is the key idea to make 
    our `PriorityQueue` pop correct items.

    In this recipe the queue consists of tuple `(-priority, idx, item)`. 
    The `priority` value is negated to get the queue to sort items from 
    **highest priority** to **lowest priority**. 
    This is opposite from normal heap ordering; which sorts items from smallest to highest value.

    The role of the `idx` value is to properly order items with the same priority level.
    By keeping a constantly increasing index, the items will be sorted according to the 
    order in which they were inserted. 
    However, the `idx` also serves an important role in making the comparision work for items
    with the smae priority level. To elaborate on this, the instances of `Item` can't be ordered.

    ```python
    ## Item class objects cannot be compared; 
    ## because we have not implemented __eq__, __le__ etc...methods to support it
    
    a = Item("foo")
    b = Item("bar")
    a < b                   ## ERROR. 
                            ## because "Item" object cannot be compared.
    ```
    ```zsh
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: unorderable types: Item() < Item()
    ```
    
    But, if you make (priority, item) tuple and compare them, then it works fine
    as long as the priorities are different.

    ```python
    ## tuples (priority, item) with different priorities.
    ## Comparision works fine

    a = (1, Item("foo"))
    b = (2, Item("bar"))
    a < b                   ## Returns "True"
                            ## because priority: 1 < 2
    ```
    So, to handle the case of same priority value; the `idx` is used. 
    The `idx` is always increasing and unique; so there is no chance of collision as shown below

    ```python
    ## Tuples (priority, idx, item) with same priorities but unique idx.
    ## Comparision works fine
    
    a = (1, 7, Item("foo"))
    b = (1, 8, Item("bar"))
    a < b                   ## Returns "True"
                            ## because idx: 7 < 8 
    ```

<!-- ######################################################################################################### -->

## 1.6: collections.defaultdict

???+ danger "Mapping Keys to multiple values in Dictionary"
    You want to make a dictionary that maps keys to more than one value
    (so called `multdict`)

???+ done "Solution"
    A dictionary is a `mapping` where each `key` is mapped to a single value.
    If you want to map keys to **multiple values**; you need to store multiple values
    in another container (like `list` or `set` or other `container types`)

    ```python
    d = {"a": [1,2,3],
         "b": [4,5],
        }

    e = {"a": {1,2,3},
         "b": {4,5},
        }
    ```
    1. Use a `list` if you want to **preserve the insertion-order** of items.
    2. Use a `set` if you want to **eliminate duplicates**.

    To easily construct such dictionaries, you can use **`collections.defaultdict`**.
    A feature of `defaultdict` is that it automatically initializes the first value so 
    you can simply focus on adding items.

    ```python
    from collections import defaultdict

    d = defaultdict(list)               ## use "list" as a constructor to initialize values map for new keys
    d["a"].append(1)                    ## d = {"a":[1]}
    d["a"].append(2)                    ## d = {"a":[1,2]}
    d["b"].append(5)                    ## d = {"a":[1,2], "b":[5]}
    d["b"].append(5)                    ## d = {"a":[1,2], "b":[5,5]}       duplication of 5 is allowed in list
    ```
    ```python
    from collections import defaultdict

    d = defaultdict(set)                ## use "set" as a constructor to initialize values map for new keys
    d["a"].add(1)                       ## d = {"a": {1}}
    d["a"].add(2)                       ## d = {"a": {1,2}}
    d["b"].add(5)                       ## d = {"a": {1,2}, "b": {5}}
    d["b"].add(5)                       ## d = {"a": {1,2}, "b": {5}}       duplicates NOT allowed in "set"
    ```

    **NOTE**: One caution with `defaultdict` is that it will automatically create dictionary entries for
    keys accessed later on (**even if they aren't found in the dictionary**) i.e. instead of throwing `KeyError`
    for keys that are not found, it adds that key to the dictinary and maps its value to the empty constructor
    (`list` or `set` etc. as above).

    If you want to avoid this behavior, its better to use usual `dict()` with `setdefault()`.
    This process is a bit messy and hard-to-read as shown below; 
    but provides user-control to handle edge cases.
    
    ```python
    d = {}                              ## a regular dictionary
    d.setdefault("a", []).append(1)     ## d = {"a": [1]}
    d.setdefault("a", []).append(2)     ## d = {"a": [1,2]}
    d.setdefault("b", []).append(5)     ## d = {"a": [1,2], "b": [5]}
    ```

???+ quote "Discussion"
    In principle, constructing a multivariate dictionary is simple.
    However, initialization of the first value can be messy if you try to do it yourself.
    Below two code-snippets show this tradeoff.

    ```python
    d = {}
    for key, value in pairs:
        if key not in d:
            d[key] = []
        d[key].append(value)

    ##--------------- v/s -----------------##
    
    from collections import defaultdict
    d = defaultdict()
    for key, value in items:
        d[key].append(value)
    ```

<!-- ######################################################################################################### -->

## 1.9: Finding commonalities in two dictionaries

???+ danger "Problem"
    You have two dictionaries and you want to find what they have in common (like same `keys`, same `values` etc.)

???+ done "Solution"
    Consider two dictionaries
    
    ```python
    a = {"x":1, "y":2, "z":3}
    b = {"w":10, "x":11, "y":2}
    ```
    To find out what the two dictionaries have in common, simply perform the common set operations
    using the `keys()` and `values()` methods.

    For example:
    ```python
    ## finding keys in common
    a.keys() & b.keys()         ##{"x", "y"}
    ```

    ```python
    ## finding keys in a, that are not in b
    a.keys() - b.keys()         ## {"z"}
    ```

    ```python hl_lines="2"
    ## finding (key, value) pair in common
    a.items() & b.items()       ## {("y", 2)}
    ```
    
    These kinds of operations can also be used to **alter** or **filter** dictionary contents.
    
    For, example, suppose you want to make a new dictionary with selected keys removed.
    Below is a sample code using a **dictionary comprehension**
    ```python
    ## make a new dictionary with certain keys removed
    c = {key:a[key] for key in a.keys()-{"z", "w"}}     ## {"x":1, "y":2}
    ```

???+ quote "Discussion"
    A **dictionary** is a mapping between a set of **keys** and **values**

    The **`.keys()`** method on a dict returns **keys-view** object of the dict.
    This keys-view object support common **set** operations like **join**, **intersection**, **difference** etc.
    These set operations are supported because it is **guranteed** that the keys of a dict are uniquely hashable.
    
    The **`.items()`**  method on a dict returns **items-view** object consisting 
    of `(key, value)` pairs. This items-view object also supports common set operations as above.

    The **`.values()`** method on the dict returns a **values-view** object consisting of values of the dict.
    BUT, this **values-view** object DOES-NOT SUPPORT common set operations 
    because the **values of a dict are not guranteed to be unique**.
    Although, if necessary we can always convert this _values-view object_ into a _set_ and 
    then perform required set-operations as usual.

