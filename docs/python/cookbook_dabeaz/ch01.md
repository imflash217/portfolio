<!-- ---
hide:
  - navigation # Hide navigation
  - toc        # Hide table of contents
--- -->

# `Data Structures & Algorithms`

`Author: Vinay Kumar (@imflash217) | Update: 07/October/2021`

<!-- ######################################################################################################### -->

## `1.1: Unpacking a sequence into separate variables`

???+ danger "Problem"
    You have a `N-element` tuple or sequence that you would like to unpack into a collection of `N` variables.

???+ done "Solution"
    1. Any **sequence** or **iterable** can be unpacked into variables using a simple assignment operation.
    2. The only requirement is that the **the number of variables and structure of the sequence must match**.

    ```python
    ##----------------------------------------------------------
    p = (4,5)   ## create a tuple
    x, y = p    ## unpack the tuple into variables 'x' & 'y'. 
                ## x=4; y=5
    ##----------------------------------------------------------
    data = ["ACME", 50, 91.1, (2021,10,07)]
    name, shares, price, date = data    ## unpack the list
                                        ## name="ACME"; shares=50
                                        ## price=91.1; date=(2021,10,07)

    ## another way to unpack the nested iterable or container
    ## name="ACME"; shares=50; price=91.1; 
    ## year = 2021; month=10; day=07
    name, shares, price, (year, month, day) = data
    ```

    If there is a mismatch in the number of elements; you will get an ERROR.
    ```python
    p = (4, 5)
    x, y, z = p
    ```
    ```console
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        ValueError: need more than 2 values to unpack
    ```

???+ quote "Discussion"
    Unpacking actually works with any object that happens to be **iterable** (tuples, lists, dicts, str, files, iteratirs, generators...)


<!-- ######################################################################################################### -->

## `1.2: Unpacking elements from iterables of arbitrary length`

???+ danger "Problem"
    You need to unpack `N` elements from an **iterable**; but the iterable may be longer than `N` elements (causing a `too many values to unpack` exception)

???+ done "Solution"
    



<!-- ######################################################################################################### -->

## `1.3 Keeping last N items`

???+ danger "Problem"
    You want to keep a limited history of last few items seen during iteration.

???+ done "Solution"
    1. Keeping a limited history is a perfect use for `collections.deque`

    ```python
    """
    Performs a simple text match on a sequence of lines
    and yields the matching line & previous N lines of context when found
    """

    from collections import deque

    def search(lines, pattern, history=5):
        previous_lines = deque(maxlen=history)
        for line in lines:
            if pattern in line:
                yield line, previous_lines
            previous_lines.append(line)

    ##-----------------------------------------------------------##
    ## Example use ona file
    if __name__ == "__main__":
        with open("somefile.txt", "r") as f:
            for line, prev_lines in search(f, "my_pattern"):
                for x in lines:
                    print(x, end="")
                print(line, end="")
                print("--"*10)
    ```


<!-- ######################################################################################################### -->

## `1.5: Priority Queue`

???+ danger "Problem"
    You want to implement a `queue` that sorts items by a given priority 
    & always **returns the item with highest priority** on each `pop` operation.

???+ done "Solution"
    The following class uses `heapq` module to implement a simple **priority queue**
    
    ```python
    import heapq
    
    class PriorityQueue:
        def __init__(self):
            self._queue = []
            self._idx = 0

        def __repr__(self):
            return self._queue

        def push(self, item, priority):
            
            ## because heappop returns the 1st item in the queue 
            ## (which has the smallest priority);
            ## So, we need to invert the priority as (-priority)
            ## Thus, we get the item with highest priority on pop

            heapq.heappush(self._queue, (-priority, self._idx, item))
            self._idx += 1

        def pop(self):
            """
            Returns item with HIGHEST priority in the priority queue
            """
            return heapq.heappop(self._queue)[-1]
    ```

    Here is an example of how we might use the above `PriorityQueue` class

    ```python
    class Item:
        def __init__(self, name):
            self.name = name

        def __repr__(self):
            return f"Item({self.name})"

    ##-----------------------------------------------------------##
    
    q = PriorityQueue()                 ## Create a priority-queue object
    q.push(Item("foo"), priority=1)     ## push an Item("foo") with priority=1
    q.push(Item("bar"), priority=5)     ## push an Item("bar") with priority=5
    q.push(Item("spam"), priority=4)    ## push an Item("spam") with priority=4
    q.push(Item("grok"), priority=1)    ## push an Item("grok") with priority=1
        
    q.pop()                             ## Item("bar")
    q.pop()                             ## Item("spam")
    q.pop()                             ## Item("foo")
    q.pop()                             ## Item("grok")
    
    ```

    In the above example note that the items with same priority (`Item("foo")` and `Item("grok")`)
    are returned in the same order as they were inserted into the queue.


