The primary focus in this article is to provide common programming patterns related
to class definitions. Some of the topics include:

1. Making objects support common Python features.
2. usage of special methods.
3. Encapsulation techniques.
4. Inheritence.
5. Memory management.
6. Useful Design Patterns.

## 8.1: __str__() & __repr__()

???+ danger "Problem"
    You want to change the output produced by printing or viewing instances to something more sensible.

???+ done "Solution"
    To change the string representation of the **class instances** define 
    **`__str__()`** & **`__repr__()`** methods as shown below.

    ```python hl_lines="5 7"
    class Pair:
        def __init__(self, x, y):
            self.x = x
            self.y = y
        def __str__(self):
            return "({0.x!s}, {0.y!s})".format(self)
        def __repr__(self):
            return "Pair({0.x!r}, {0.y!r})".format(self)
    ```
    
    :trophy: The **`__repr__()`** method returns the code represntation of the instance,
    and is usually the code you would type to re-create the instance.
    The built-in **`repr()`** function returns this text and so does the interactive interpreter
    while inspecting values.

    :trophy: The **`__str__()`** method converts the instance to a string and is the output returned by **`print()`**
    or **`str()`** methods.

    ```ipython
    >>> p = Pair(2, 3)
    >>> p
    Pair(2, 3)              ## __repr__() output
    >>> print(p)
    >>> (2, 3)              ## __str__() output
    ```

    :rotating_light: The implementation of the above class also show how different string representations 
    may be used during formatting. Specifically, the special **`!r`** formatting code
    indicates that the output of **`__repr__()`** should be used instead of **`__str__()`**, the default.
    An example below shows this behavior:

    ```ipython hl_lines="3 5"
    >>> p = Pair(3, 4)
    >>> print("p is {0!r}").format(p)
    p is Pair(3, 4)
    >>> print("p is {0!s}").format(p)
    p is (3, 4)
    ```

???+ quote "Discussion"
    :rotating_light: It is standard practice to for the output of **`__repr__()`** 
    to produce text such that **`eval(repr(x)) == x`**
    
    If it is not prossible or desired then it is common to create a textual represntation enclosed in **`<` & `>`** instead
    as shown in below snippet.

    ```ipython
    >>> f = open("file.dat")
    >>> f
    <_io.TextIOWrapper name='file.dat' mode='r' encoding='utf-8'>

    ```

    :rotating_light: If not **`__str__()`** is provided then **`__repr__()`** is used as a fallback.


## 8.2: Customizing string formatting

???+ danger "Problem"
    You want an object to support customized formatting through the **`formaat()`** function and string method.

???+ done "Solution"
    To customize string formatting, define a custom **`__format__()`** method in the class definition.
    For example:

    ```python hl_lines="3-7 17"
    ## The format codes
    ##
    _formats = {
        "ymd": "{d.year}-{d.month}-{d.day}",
        "mdy": "{d.month}/{d.day}/{d.year}",
        "dmy": "{d.day}/{d.month}/{d.year}"
    }
    
    ## ----------------------------------------------- ##

    class date:
        def __init__(self, day, month, year):
            self.day = day
            self.month = month
            self.year = year

        def __format__(self, code):
            if code == "":
                code = "ymd"
            fmt = _formats[code]
            return fmt.format(d=self)
    ```

    Instances of **`Date`** now supports formatting options such as the following:
    
    ```ipython
    >>> d = Date(15, 11, 2021)
    >>>
    >>> format(d)
    '2021-11-15'
    >>>
    >>> format(d, "mdy")
    '11-15-2021'
    >>>
    >>> "The date is {:ymd}".format(d)
    'The date is 2021-11-15'
    >>>
    >>> "The date is {:mdy}".format(d)
    'The date is 11-15-2021'
    ```

    -------------------------------

    The **`__format__()`** method provides HOOK into Python's string formatting functionality.
    
    :trophy: Its important to know that the interpretation of the format codes (e.g. **`_formats`** in above code)
    is entirely upto the class defintion and developer.


## 8.6: Creating managed attributes

???+ danger "Problem"
    You want to add extra processing (e.e. type checking, validation) to the **getting** and **setting**
    of the instance attributes

???+ done "Solution"
    :rotating_light: A simple way to **customize** access to an attribute is to define it as **`property`**.
    
    For example, in below code, we define a **`property`** that adds simple type checking for its
    **`getter`** and **`setter`** methods.

    ```python hl_lines="3 8"
    class Person:
        def __init__(self, first_name):
            self.first_name = first_name        ## NOTE: I'm defining "self.first_name" not "self._first_name"

        ## getter method
        @property
        def first_name(self):
            return self._first_name

        ## setter method
        @first_name.setter
        def first_name(self, value):
            if not isinstance(value, str):
                raise TypeError("Expected a string")
            self._first_name = value

        ## deleter method
        @first_name.deleter
        def first_name(self):
            raise AttributeError("Can't delete attribute")

    ```

