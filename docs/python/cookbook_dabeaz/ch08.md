The primary focus in this article is to provide common programming patterns related
to class definitions. Some of the topics include:

1. Making objects support common Python features.
2. usage of special methods.
3. Encapsulation techniques.
4. Inheritence.
5. Memory management.
6. Useful Design Patterns.

## 8.1: __str__() & __repr__()

???+ danger "Problem"
    You want to change the output produced by printing or viewing instances to something more sensible.

???+ done "Solution"
    To change the string representation of the **class instances** define 
    **`__str__()`** & **`__repr__()`** methods as shown below.

    ```python hl_lines="5 7"
    class Pair:
        def __init__(self, x, y):
            self.x = x
            self.y = y
        def __str__(self):
            return "({0.x!s}, {0.y!s})".format(self)
        def __repr__(self):
            return "Pair({0.x!r}, {0.y!r})".format(self)
    ```
    
    :trophy: The **`__repr__()`** method returns the code represntation of the instance,
    and is usually the code you would type to re-create the instance.
    The built-in **`repr()`** function returns this text and so does the interactive interpreter
    while inspecting values.

    :trophy: The **`__str__()`** method converts the instance to a string and is the output returned by **`print()`**
    or **`str()`** methods.

    ```ipython
    >>> p = Pair(2, 3)
    >>> p
    Pair(2, 3)              ## __repr__() output
    >>> print(p)
    >>> (2, 3)              ## __str__() output
    ```

    :rotating_light: The implementation of the above class also show how different string representations 
    may be used during formatting. Specifically, the special **`!r`** formatting code
    indicates that the output of **`__repr__()`** should be used instead of **`__str__()`**, the default.
    An example below shows this behavior:

    ```ipython hl_lines="3 5"
    >>> p = Pair(3, 4)
    >>> print("p is {0!r}").format(p)
    p is Pair(3, 4)
    >>> print("p is {0!s}").format(p)
    p is (3, 4)
    ```

???+ quote "Discussion"
    :rotating_light: It is standard practice to for the output of **`__repr__()`** 
    to produce text such that **`eval(repr(x)) == x`**
    
    If it is not prossible or desired then it is common to create a textual represntation enclosed in **`<` & `>`** instead
    as shown in below snippet.

    ```ipython
    >>> f = open("file.dat")
    >>> f
    <_io.TextIOWrapper name='file.dat' mode='r' encoding='utf-8'>

    ```

    :rotating_light: If not **`__str__()`** is provided then **`__repr__()`** is used as a fallback.


## 8.2: Customizing string formatting

???+ danger "Problem"
    You want an object to support customized formatting through the **`formaat()`** function and string method.

???+ done "Solution"
    To customize string formatting, define a custom **`__format__()`** method in the class definition.
    For example:

    ```python
    _formats = {
        "ymd": "{d.year}-{d.month}-{d.day}",
        "mdy": "{d.month}/{d.day}/{d.year}",
        "dmy": "{d.day}/{d.month}/{d.year}"
    }

    class date:
        def __init__(self, day, month, year):
            self.day = day
            self.month = month
            self.year = year

        def __format__(self, code):
            if code == "":
                code = "ymd"
            fmt = _formats[code]
            return fmt.format(d=self)
    ```
