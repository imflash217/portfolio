Writing functions using `def` is a cornerstone of all programs.
In this tutorial we will look into some of the advance usage of functions
viz.

1. closures
2. callback-functions
3. control-flow
4. keyword-only arguments
5. default-arguments
6. annotations
7. any-number-of-arguments (`*args` & `**kwargs`) etc.

## 7.1: Function with any number of arguments (`*args, **kwargs`)

???+ danger "Problem"
    You want to write a function that accepts any number of arguments.

???+ done "Solution"
    :rotating_light: For a function that accepts any number of **positional** arguments use a **`*`** argument.
    
    :rotating_light: For a function that accepts any number of **keyword** arguments use a `**` argument.

    To write any function that accepts any numbe rof positional arguments, use a **`*`** argument as shown below.
    In this example, **`rest`** is a **`tuple`** of all extra positional arguments passed.
    In above code, it is treated as a **`sequence`** in further calculations inside the function.

    ```python hl_lines="1"
    def avg(first, *rest):
        return (first + sum(rest)) / (1 + len(rest))

    ## ------------------------------------------------- ##

    avg(1, 2, 3)        ## return=2.0; first=1, rest=(2, 3)
    avg(1, 2, 3, 4)     ## return=2.5; first=1, rest=(2, 3, 4)
    ```

    To accept any number of **keyword arguments** use a `**` argument as shown below. 
    In the below code, **`attrs`** is a **dictionary** that holds the passed keyword arguments (if any)

    ```python hl_lines="3"
    import html

    def make_element(name, value, **attrs):
        keyvals = [f"{key}='{val}'" for key, val in atts.items]
        attr_str = "".join(keyvals)
        element = f"<{name}{attr_str}>{html.escape(value)}</{value}>"
        return element
    ```
    ```python
    ## Creates: "<item size='large' quantity=6>Albatross</item>"
    make_element("item", "Albatross", size="large", quantity=6)
    ```
    ```python
    ## Creates: "<p>&lt;spam&gt;</p>"
    make_element(p, "<spam>")
    ```

    :trophy: If you want a function that accepts both any-number-of-positional-arguments aswell as
    any-number-of-keyword-arguments use both **`*`** & `**` arguments as shown below

    ```python hl_lines="1"
    def anyargs(*args, **kwargs):
        print(args)     ## a tuple
        print(kwargs)   ## a dictionary
    ```

???+ quote "Discussion"
    :rotating_light: A **`*`** argument can only appear as the **last positional argument** in a function
    and a `**` argumnet can only appear as the **last argumnet** in a function.

    :trophy: A subtle aspect of function definition is that arguments can still appear 
    after a **`*`** argument by they are treated as keyword argument only (as discussed in further lessons).

    ```python
    ## valid function definitions
    def a(x, *args, y): pass
    def b(x, *args, y, **kwargs): pass


    ## WRONG function defintions
    ## here argument "z" appears after `**kwargs`; hence its a WRONG definition
    
    def c(x, *args, **kwargs, z): pass
    
    ```

## 7.2: Keyword-only arguments

???+ danger "Problem"
    You want to write a function that accepts **only keyword arguments**.

???+ done "Solution"
    This feature is easy to implement if you place the **keyword argument** after the **`*`** argument
    or **a single unnamed `*`** as shown below.

    ```python hl_lines="1 7"
    def recv(maxsize, *, block):
        """Receives a message"""
        pass

    ##-------------------------------------##

    recv(1024, True)            ## Type Error
    recv(2024, block=True)      ## OK
    ```

    This technique can also be used to specify keyword arguments for functions that
    accept **varying numbe rof positional arguments** as shown below.

    ```python hl_lines="1"
    def minimum(*values, clip=None):
        m = min(values)
        if clip is not None:
            m = clip if clip > m else m
        return m

    ## ----------------------------------------- ##

    minimum(1, 2, 5, -5, 10)            ## -5
    minimum(1, 2, 5, -5, 10, clip=0)    ## 0
    ```

???+ quote "Discussion"
    :rotating_light: **Keyword-only arguments** are a good way to enforce greater code-clarity when
    specifying optional function arguments. For example consider the following code:

    ```python
    msg = recv(1024, False)
    ```
    If someone is not familiar with **`recv`** (written in above section), they might not know 
    what does **`False`** mean in this scenario. On the other hand, its much clearer to the user 
    if someone writes the call as below:

    ```python
    msg = recv(1024, block=False)
    ```
    
    :trophy: The use of keyword-only arguments is often very useful for tricks involving `**kwargs`,
    since they show up nicely when the user asks for `help()`

    ```zsh
    >>> help(recv)
    Help on function recv in module __main__:
    recv(maxsize, *, block):
        """Receives a message"""
    ```

    :trophy: Keyword-only arguments also have utility in advance usage like **argument injection** 
    using `*args` & `**kwargs`.


## 7.3: Function argument annotations

???+ danger "Problem"
    You've written a function but you want add some additional information about the **arguments**
    so that users can know more easily how a function is supposed to be used.

???+ done "Solution"
    **Function argument annotations** can be very useful in givin gprogrammers hint about how a function is supposed to be used.
    Cosider the following **annotated** function.

    ```python
    ## normal function definition
    def add(x, y):
        return x + y

    ## Annotated function definition -- MUCH BETTER for users
    def add(x:int, y:int) -> int:
        return x + y
    ```

    :rotating_light: The Python Interpretr does not add any semantic meaning to the attached annotations.
    Neither are they type-cheked nor does Puython behave any differently than before.
    However, they might give useful hunts about types that would be useful for users or third-party libraries.

???+ quote "Discussion"
    
